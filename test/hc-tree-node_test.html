<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>hc-tree-node test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="utils.html">
    <link rel="import" href="../hc-tree-node.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <hc-tree-node></hc-tree-node>
      </template>
    </test-fixture>

    <script>
      describe('hc-tree-node', () => {
        let element;

        beforeEach(() => {
          element = fixture('basic');
        });

        // Lifecycle Functions
        describe('ready()', () => {
          it('should transition state from null to "on" when _regularTap', () => {
            element.state = null;
            element.$.checkbox.click();
            expect(element.state).to.equal('on');
          });
          it('should transition state from "on" to "off" when _regularTap', () => {
            element.state = 'on';
            element.$.checkbox.click();
            expect(element.state).to.equal('off');
          });
          it('should transition state from "off" to "on" when _regularTap', () => {
            element.state = 'off';
            element.$.checkbox.click();
            expect(element.state).to.equal('on');
          });
        });
        // Private Functions
        describe('_selectedChanged(selected, indeterminateIsSelected)', () => {
          beforeEach(() => {
            element._stateChanged = sinon.spy();
            element.fire = sinon.spy();
          });

          it('should fire the item-selected-changed event', () => {
            element._selectedChanged(true);
            expect(element.fire.calledWith('item-selected-changed', {item: element.item, selected: true})).
              to.equal(true);
          });
          // Basic cases
          it('should update state to "on" when selected and state is "off"', () => {
            element.state = 'off';
            element._selectedChanged(true);
            expect(element.state).to.equal('on');
          });
          it('should update state to "off" when !selected and state is "on"', () => {
            element.state = 'on';
            element._selectedChanged(false);
            expect(element.state).to.equal('off');
          });
          // Indeterminate cases
          it('should update state to "on" when state is null and !indeterminateIsSelected and selected', () => {
            element.state = null;
            element._selectedChanged(true, false);
            expect(element.state).to.equal('on');
          });
          it('should update state to "off" when state is null and indeterminateIsSelected and !selected', () => {
            element.state = null;
            element._selectedChanged(false, true);
            expect(element.state).to.equal('off');
          });
          // No change cases
          it('should not update state when selected and state is "on"', () => {
            element.state = 'on';
            element._selectedChanged(true);
            expect(element.state).to.equal('on');
          });
          it('should not update state when !selected and state is "off"', () => {
            element.state = 'off';
            element._selectedChanged(false);
            expect(element.state).to.equal('off');
          });
          it('should not update state for all other cases', () => {
            element.state = null;
            element._selectedChanged(true, true);
            expect(element.state).to.equal(null);
            element._selectedChanged(false, false);
            expect(element.state).to.equal(null);
          });
        });
        describe('_stateChanged(state, indeterminateIsSelected, hasChildren)', () => {
          beforeEach(() => {
            element.fire = sinon.spy();
            element._selectedChanged = sinon.spy();
          });

          it('should fire a item-state-changed event', () => {
            element._stateChanged('off');
            expect(element.fire.calledWith('item-state-changed', {item: element.item, state: 'off'})).
              to.equal(true);
          });
          it('should set state to "on" when state is null and !hasChildren', () => {
            element.state = null;
            element._stateChanged(element.state, false, false);
            expect(element.state).to.equal('on');
          });
          it('should not update state when hasChildren', () => {
            element.state = null;
            element._stateChanged(element.state, false, true);
            expect(element.state).to.equal(null);
          });
          // Basic cases
          it('should update selected to true when state is "on" and !selected', () => {
            element.selected = false;
            element._stateChanged('on');
            expect(element.selected).to.equal(true);
          });
          it('should update selected to false when state is "off" and selected', () => {
            element.selected = true;
            element._stateChanged('off');
            expect(element.selected).to.equal(false);
          });
          // Indeterminate cases
          it('should update selected to true when state is null and indeterminateIsSelected and !selected', () => {
            element.selected = false;
            element._stateChanged(null, true, true);
            expect(element.selected).to.equal(true);
          });
          it('should update selected to false when state is null and !indeterminateIsSelected and selected', () => {
            element.selected = true;
            element._stateChanged(null, false, true);
            expect(element.selected).to.equal(false);
          });
          // No change cases
          it('should not update selected when state is "on" and selected', () => {
            element.selected = true;
            element._stateChanged('on');
            expect(element.selected).to.equal(true);
          });
          it('should not update selected when state is "off" and !selected', () => {
            element.selected = false;
            element._stateChanged('off');
            expect(element.selected).to.equal(false);
          });
          it('should not update selected for all other cases', () => {
            element.selected = false;
            element._stateChanged(null, false, true);
            expect(element.selected).to.equal(false);
            element.selected = true;
            element._stateChanged(null, true, true);
            expect(element.selected).to.equal(true);
          });
        });
        describe('_stopPropagation(event)', () => {
          it('should stop event propagation', () => {
            const event = {
              stopPropagation: sinon.spy()
            };
            element._stopPropagation(event);
            expect(event.stopPropagation.calledOnce).to.equal(true);
          });
          it('should be called when checkbox is clicked', () => {
            element.item = {};
            element._stopPropagation = sinon.spy();
            element.$$('paper-tristate-checkbox').click();
            expect(element._stopPropagation.calledOnce).to.equal(true);
          });
        });
      });
    </script>
  </body>
</html>
