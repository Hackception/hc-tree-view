<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>hc-nested-list test</title>

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>

    <link rel="import" href="utils.html">
    <link rel="import" href="../hc-nested-list.html">
  </head>
  <body>
    <test-fixture id="basic">
      <template>
        <hc-nested-list>
          <template>
            <div class="item">
              <paper-checkbox></paper-checkbox>
              <iron-icon icon="icons:add-circle-outline"></iron-icon>
              <span>[[item.label]]</span>
            </div>
          </template>
        </hc-nested-list>
      </template>
    </test-fixture>

    <script>
      describe('hc-nested-list', () => {
        const count = 5;
        let element, items, parts;

        beforeEach(() => {
          // Triggers a clean build of items and parts every time.
          parts = {};
          items = window.buildItems(count, count, count, parts);

          element = fixture('basic');
          element.set = sinon.spy();
        });

        // Private Functions
        describe('_computeItems(parts)', () => {
          it('should turn a parts object into an array', () =>
            expect(element._computeItems(parts)).to.deep.equal(parts.root));
          it('should nest children after the parent when parent is open', () => {
            const p = Object.assign({}, parts);
            const parents = Object.assign([], p.root);
            const parent = parents[1];
            parent.open = true;
            const children = Object.assign([], p[parent.id]);
            const child = children[1];
            child.open = true;

            const i = [
              parents.shift(),
              parents.shift(),
              children.shift(),
              children.shift()
            ];
            // Push all grandchildren
            i.push(...p[child.id]);
            // Push remaining children
            i.push(...children);
            // Push remaining parents
            i.push(...parents);
            expect(element._computeItems(p)).to.deep.equal(i);
          });
          it('should be called when parts changes', () => {
            element._computeItems = sinon.spy();
            element.parts = {};
            expect(element._computeItems.calledOnce).to.equal(true);
          });
        });
        describe('_computeParts(items)', () => {
          it('should turn an array of items into a map based on the parentId', () => {
            element._computeParts(items);
            expect(element.set.calledWith('parts', parts)).to.equal(true);
          });
          it('should be called whne items is updated', () => {
            element._computeParts = sinon.spy();
            element.items = [];
            expect(element._computeParts.calledOnce).to.equal(true);
          });
        });
        describe('_getParentId(item)', () => {
          it('should return item.parentId when it is truthy', () =>
            expect(element._getParentId({parentId: 'a'})).to.equal('a'));
          it('should return root when item.parentId is falsey and !== 0', () =>
            expect(element._getParentId({})).to.equal('root'));
          it('should return 0 when item.parentId === 0', () =>
            expect(element._getParentId({parentId: 0})).to.equal(0));
          it('should return root when item.parentId is an empty string', () =>
            expect(element._getParentId({parentId: ''})).to.equal('root'));
        });
        // Public Functions
        describe('fetchChildren(item, parts, update)', () => {
          let spy;

          beforeEach(() => spy = sinon.spy());

          it('should call set on parts with the parts object', () => {
            element.fetchChildren({}, {test: 'test'}, spy);
            expect(spy.calledOnce).to.equal(true);
            expect(spy.calledWith({test: 'test'})).to.equal(true);
          });
        });
        describe('toggleOpen(event, detail)', () => {
          const event = {};
          let fetchChildrenSpy;

          beforeEach(() => {
            event.detail = {
              item: Object.assign({}, parts.root[0])
            };
            fetchChildrenSpy = sinon.spy(element, 'fetchChildren');
          });

          it('should toggle open state to true for the element and call fetchChildren', () => {
            element.parts = parts;
            element.toggleOpen(event, event.detail);
            expect(element.set.calledOnce).to.equal(true);
            expect(element.set.calledWith('parts')).to.equal(true);
            expect(element.set.args[0][1].root[0].open).to.equal(true);
            expect(fetchChildrenSpy.calledWithMatch(element.parts.root[0], element.parts)).to.equal(true);
          });
          it('should toggle open state to false for all other elements at the same level', () => {
            parts.root[1].open = true;
            element.parts = parts;
            element.toggleOpen(event, event.detail);
            expect(element.set.calledOnce).to.equal(true);
            expect(element.set.calledWith('parts')).to.equal(true);
            expect(element.set.args[0][1].root[0].open).to.equal(true);
            expect(element.set.args[0][1].root[1].open).to.equal(false);
          });
          it('should toggle open state to false if it was already true', () => {
            parts.root[0].open = true;
            element.parts = parts;
            element.toggleOpen(event, event.detail);
            expect(element.set.calledOnce).to.equal(true);
            expect(element.set.calledWith('parts')).to.equal(true);
            expect(element.set.args[0][1].root[0].open).to.equal(false);
          });
          it('should run the cb function if it is provided', done => {
            event.detail.cb = item => {
              expect(item).to.deep.equal(Object.assign(event.detail.item, {open: true}));
              done();
            };
            element.parts = parts;
            element.toggleOpen(event, event.detail);
          });
          it('should not run if isLoading is true', () => {
            element.isLoading = true;
            element.toggleOpen(event, event.detail);
            expect(fetchChildrenSpy.called).to.equal(false);
          });
          it('should run when the toggle event is fired', done => {
            element.toggleOpen = sinon.spy();
            element.fire('toggle');
            flush(() => {
              expect(element.toggleOpen.calledOnce).to.equal(true);
              done();
            });
          });
        });
      });
    </script>
  </body>
</html>
