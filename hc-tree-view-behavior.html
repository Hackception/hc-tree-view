<link rel="import" href="../polymer/polymer.html">

<script>
  /* global hc */
  // Ensure our namespace exists
  window.hc = window.hc || {};

  /**
   * Use `hc.TreeViewBehavior` to implement a tree based around a flat data structure and built on top of
   *  `hc-nested-list`.
   *
   * @polymerBehavior hc.TreeViewBehavior
   */
  hc.TreeViewBehavior = {
    properties: {
      /* Used to allow changing what the tree node's id is */
      itemIdName: {
        type: String,
        value: 'id',
      },
      /* Used to allow changing what the tree node's parent id is */
      itemParentIdName: {
        type: String,
        value: 'parentId',
      },
      /* The list of items to display in the tree, using a flat structure */
      items: Array,
      /* The hc-nested-list element to use for rendering */
      list: {
        type: Object,
        notify: true,
      },
      /* The list of all selected items without duplicates */
      selectedItems: {
        type: Array,
        value() {
          return [];
        },
        notify: true,
        // TODO: Maybe major break. Verify other locations where used.
        // TODO: remove _setSelectedItems if not used.
        readOnly: true
      },
      /**
       * The parts object used by the list element
       *
       * @private
       */
      _parts: Object,
    },
    ready() {
      this.itemSelectedChanged = this.itemSelectedChanged.bind(this);
      this.itemStateChanged = this.itemStateChanged.bind(this);
    },
    attached() {
      this.addEventListener('item-selected-changed', this.itemSelectedChanged);
      this.addEventListener('item-state-changed', this.itemStateChanged);
    },
    detached() {
      this.removeEventListener('item-selected-changed', this.itemSelectedChanged);
      this.removeEventListener('item-state-changed', this.itemStateChanged);
    },
    /**
     * Collapses the tree while maintaining the current selection states
     *
     * @param {Array.<Object>} [items = this.items]
     * @param {Object} [parts = this._parts]
     * @param {Boolean} [preventUpdate] - blocks the update to parts and blocks template updating
     */
    collapse(items = this.items, parts = this._parts, preventUpdate = false) {
      if (!items.length) return;

      for(let i = 0; i < items.length; i++) {
        const item = items[i];
        item.open = false;

        if (!item[this.itemParentIdName])
          parts.root[item[this.itemIdName]].open = false;

        const itemParts = parts[items[i][this.itemIdName]];
        if (itemParts)
          this.collapse(itemParts, parts, true);
      }

      if (!preventUpdate)
        this.debounce('collapseUpdate', () => {
          this.set('_parts', Object.assign({}, this._parts));
        });
    },
    /**
     * Takes an array of one or more items and removes them from the selectedItems array.  If no items are passed
     *  then all items will be deslected.
     *
     * @param {Array.<Object>} [items]
     * @param {Boolean} [preventUpdate] - blocks the call to _updateState to block template updating
     */
    deselectItems(items, preventUpdate) {
      if (!items) {
        items = this.selectedItems;
        this._setSelectedItems([]);
      } else {
        const getNodeId = (i) => i[this.itemIdName];
        const itemsToUpdate = [];

        items.forEach((item) => {
          const index = this.selectedItems.findIndex((i) => {
            const match = getNodeId(i) === getNodeId(item);
            if (match) {
              itemsToUpdate.push(i);
            }
            return match;
          });
          if (index >= 0) {
            this.selectedItems.splice(index, 1);
          }
        });

        items = itemsToUpdate;
        if (items.length) {
          this._setSelectedItems(Object.assign([], this.selectedItems));
        }
      }
      if (!preventUpdate) this._updateState(items, 'off');
    },
    /**
     * Fetches the parent for the given item.
     *
     * @param {Object} item
     * @return {Object|undefined}
     */
    getParent(item) {
      return this.list.getParent(item);
    },
    /**
     * Makes calls to select or deselect the item based on the selected in the event.
     *
     * @listens hc-tree-view-behavior#item-selected-changed
     * @param {CustomEvent} event
     */
    itemSelectedChanged({detail}) {
      if (detail.selected) {
        this.selectItems([detail.item], true);
      } else {
        this.deselectItems([detail.item], true);
      }
      if (detail.state !== undefined && Polymer.Element) {
        this._updateState([detail.item], detail.state)
      }
    },
    /**
     * Updates the parents and children of this item that it's state was changed, update thiers as well if needed.
     *
     * @listens hc-tree-view-behavior#item-state-changed
     * @param {CustomEvent} event
     */
    itemStateChanged({detail}) {
      const {item, state} = detail;

      if (item.state !== state) {
        item.state = state;
      }

      // Change selected status for parents up the chain
      const parent = this._updateParents(item, state);
      if (parent) {
        if (parent.state === 'on') {
          this.selectItems([parent], true);
        } else {
          this.deselectItems([parent], true);
        }
      }

      // Change selected status for children, even if they are hidden.
      if (state === 'on') {
        this.selectItems(this._updateChildren(item, state), true);
      } else {
        this.deselectItems(this._updateChildren(item, state), true);
      }

      this.debounce('itemStateChanged', () => {
        this.set('_parts', Object.assign({}, this._parts));
      });
    },
    /**
     * Clears all state from the tree, resetting back to the original tree.
     */
    reset() {
      this.deselectItems();
      this.set('items', Object.assign([], this.items));
    },
    /**
     * Takes an array of one or more items adds them to the selectedItems array, preventing duplicates.
     *
     * @param {Array.<Object>} items
     * @param {Boolean} [preventUpdate] - blocks the call to _updateState to block template updating
     * @param {String} [itemIdName = this.itemIdName] - Name of the id field uniquely
     * identifying nodes.
     */
    selectItems(items, preventUpdate, itemIdName = this.itemIdName) {
      if (!Array.isArray(items)) return;
      // Add all of the items to the selectedItems as a set
      const selectedSet = new Set(this.selectedItems);
      const itemsToAdd = this.__uniqueItems(items, Array.from(selectedSet));
      itemsToAdd.forEach((item) => selectedSet.add(item));

      // Update selectedItems with an array version if an item was added
      // TODO Will this impact optimization?
      if (Array.isArray(itemsToAdd) && itemsToAdd.length) {
        this._setSelectedItems(Array.from(selectedSet));
        if (!preventUpdate) this._updateState(items, 'on');
      }
    },
    /**
     * Updates the state on all children for the given item, returning the items that were updated.
     *
     * @private
     * @param {Object} item
     * @param {Boolean} state
     * @param {Object} [parts = this._parts]
     * @return {Array.<Object>}
     */
    _updateChildren(item, state, parts = this._parts) {
      const children = parts[item[this.itemIdName]];
      if (!children || !state) return [];

      const updatedChildren = [];

      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // Only update the children if the state actually changes.
        if (child.state !== state) {
          child.state = state;
          updatedChildren.push(children[i]);
          updatedChildren.push(...this._updateChildren(child, state, parts));
        }
      }

      return updatedChildren;
    },
    /**
     * Updates the state on the parent for the given item and all of it's parents.
     *
     * @private
     * @param {Object} item
     * @param {Boolean} state
     * @param {Object} [parts = this._parts]
     * @return {Object|undefined} - Parent of the item if it exists
     */
    _updateParents(item, state, parts = this._parts) {
      // Update up the chain (parents)
      const parent = this.getParent(item);

      if (parent && parent.state !== state) {
        const siblings = parts[parent[this.itemIdName]];
        const prevState = parent.state;

        // If all of the siblings share the same state then set it for the parent, otherwise it's indeterminate
        const newState = siblings.every((i) => i.state === state) ? state : null;

        // If there's a change, update
        if (prevState !== newState) {
          parent.state = newState;
          this._updateParents(parent, state, parts);
        }
      }
      return parent;
    },
    /**
     * Takes a list of items and updates their state in parts.
     *
     * @private
     * @param {Array.<Object>} items
     * @param {String} state
     * @param {Object} [parts = this._parts]
     */
    _updateState(items, state, parts = this._parts) {
      if (!items || !parts) return;
      // Filter items to remove children that have a parent in the array
      items = items.filter((item) => {
        item.state = state;
        return !items.some((i) => i[this.itemIdName] === item[this.itemParentIdName]);
      });
      // Pass the filtered items into _updateChildren
      items.forEach((item) => {
        // Find the item in the parts object
        const parentId = this.list._getParentId(item);
        const partItem = parts[parentId].find((i) => {
          return i[this.itemIdName] === item[this.itemIdName];
        });
        // Trigger a state change that will propagate
        this.itemStateChanged({
          detail: {
            item: partItem,
            state,
          },
        });
      });
    },
    // TODO JSDOC
    // TODO Cleanup
    __uniqueItems(items, referenceItems = this.selectedItems, uniqueIdentifier = this.itemIdName) {
      if (!Array.isArray(items) || !Array.isArray(referenceItems)) return [];
      // Take the set difference of the two items
      const uniqueItems = new Set(items.
        filter((item) => item && item[uniqueIdentifier]).
        filter((item) => {
          const alreadyPresent = referenceItems.some((referenceItem) => {
            return referenceItem[uniqueIdentifier] === item[uniqueIdentifier];
          });
          return !alreadyPresent;
        }));
      return Array.from(uniqueItems);
    }
  };
  /**
   * Event for changing the selection status of a tree node
   *
   * @event hc-tree-view-behavior#item-selected-changed
   * @type {Object}
   * @property {Object} item - the item to change selection status for
   * @property {Boolean} selection - the updated selection status
   * @property {String} [state] - triggers a state update, can be 'on', 'off', or null
   */
  /**
   * Event for changing the state of a tree node
   *
   * @deprecated
   * @event hc-tree-view-behavior#item-state-changed
   * @type {Object}
   * @property {Object} item - the item to change state for
   * @property {String} state - the updated state, can be 'on', 'off', or null
   */
</script>
